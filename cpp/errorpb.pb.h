// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: errorpb.proto

#ifndef PROTOBUF_errorpb_2eproto__INCLUDED
#define PROTOBUF_errorpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace errorpb {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_errorpb_2eproto();
void protobuf_InitDefaults_errorpb_2eproto();
void protobuf_AssignDesc_errorpb_2eproto();
void protobuf_ShutdownFile_errorpb_2eproto();

class Error;
class KeyNotInRegion;
class NotLeader;
class RaftEntryTooLarge;
class RegionNotFound;
class ServerIsBusy;
class StaleCommand;
class StaleEpoch;
class StoreNotMatch;

// ===================================================================

class NotLeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.NotLeader) */ {
 public:
  NotLeader();
  virtual ~NotLeader();

  NotLeader(const NotLeader& from);

  inline NotLeader& operator=(const NotLeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotLeader& default_instance();

  static const NotLeader* internal_default_instance();

  void Swap(NotLeader* other);

  // implements Message ----------------------------------------------

  inline NotLeader* New() const { return New(NULL); }

  NotLeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotLeader& from);
  void MergeFrom(const NotLeader& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotLeader* other);
  void UnsafeMergeFrom(const NotLeader& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 region_id = 1;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // optional .metapb.Peer leader = 2;
  bool has_leader() const;
  void clear_leader();
  static const int kLeaderFieldNumber = 2;
  const ::metapb::Peer& leader() const;
  ::metapb::Peer* mutable_leader();
  ::metapb::Peer* release_leader();
  void set_allocated_leader(::metapb::Peer* leader);

  // @@protoc_insertion_point(class_scope:errorpb.NotLeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::Peer* leader_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NotLeader> NotLeader_default_instance_;

// -------------------------------------------------------------------

class StoreNotMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StoreNotMatch) */ {
 public:
  StoreNotMatch();
  virtual ~StoreNotMatch();

  StoreNotMatch(const StoreNotMatch& from);

  inline StoreNotMatch& operator=(const StoreNotMatch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreNotMatch& default_instance();

  static const StoreNotMatch* internal_default_instance();

  void Swap(StoreNotMatch* other);

  // implements Message ----------------------------------------------

  inline StoreNotMatch* New() const { return New(NULL); }

  StoreNotMatch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreNotMatch& from);
  void MergeFrom(const StoreNotMatch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StoreNotMatch* other);
  void UnsafeMergeFrom(const StoreNotMatch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.StoreNotMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<StoreNotMatch> StoreNotMatch_default_instance_;

// -------------------------------------------------------------------

class RegionNotFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.RegionNotFound) */ {
 public:
  RegionNotFound();
  virtual ~RegionNotFound();

  RegionNotFound(const RegionNotFound& from);

  inline RegionNotFound& operator=(const RegionNotFound& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionNotFound& default_instance();

  static const RegionNotFound* internal_default_instance();

  void Swap(RegionNotFound* other);

  // implements Message ----------------------------------------------

  inline RegionNotFound* New() const { return New(NULL); }

  RegionNotFound* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionNotFound& from);
  void MergeFrom(const RegionNotFound& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegionNotFound* other);
  void UnsafeMergeFrom(const RegionNotFound& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 region_id = 1;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.RegionNotFound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RegionNotFound> RegionNotFound_default_instance_;

// -------------------------------------------------------------------

class KeyNotInRegion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.KeyNotInRegion) */ {
 public:
  KeyNotInRegion();
  virtual ~KeyNotInRegion();

  KeyNotInRegion(const KeyNotInRegion& from);

  inline KeyNotInRegion& operator=(const KeyNotInRegion& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyNotInRegion& default_instance();

  static const KeyNotInRegion* internal_default_instance();

  void Swap(KeyNotInRegion* other);

  // implements Message ----------------------------------------------

  inline KeyNotInRegion* New() const { return New(NULL); }

  KeyNotInRegion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyNotInRegion& from);
  void MergeFrom(const KeyNotInRegion& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyNotInRegion* other);
  void UnsafeMergeFrom(const KeyNotInRegion& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional uint64 region_id = 2;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 2;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // optional bytes start_key = 3;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 3;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // optional bytes end_key = 4;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 4;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // @@protoc_insertion_point(class_scope:errorpb.KeyNotInRegion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  ::google::protobuf::uint64 region_id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<KeyNotInRegion> KeyNotInRegion_default_instance_;

// -------------------------------------------------------------------

class StaleEpoch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleEpoch) */ {
 public:
  StaleEpoch();
  virtual ~StaleEpoch();

  StaleEpoch(const StaleEpoch& from);

  inline StaleEpoch& operator=(const StaleEpoch& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleEpoch& default_instance();

  static const StaleEpoch* internal_default_instance();

  void Swap(StaleEpoch* other);

  // implements Message ----------------------------------------------

  inline StaleEpoch* New() const { return New(NULL); }

  StaleEpoch* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StaleEpoch& from);
  void MergeFrom(const StaleEpoch& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StaleEpoch* other);
  void UnsafeMergeFrom(const StaleEpoch& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .metapb.Region new_regions = 1;
  int new_regions_size() const;
  void clear_new_regions();
  static const int kNewRegionsFieldNumber = 1;
  const ::metapb::Region& new_regions(int index) const;
  ::metapb::Region* mutable_new_regions(int index);
  ::metapb::Region* add_new_regions();
  ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
      mutable_new_regions();
  const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
      new_regions() const;

  // @@protoc_insertion_point(class_scope:errorpb.StaleEpoch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::metapb::Region > new_regions_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<StaleEpoch> StaleEpoch_default_instance_;

// -------------------------------------------------------------------

class ServerIsBusy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.ServerIsBusy) */ {
 public:
  ServerIsBusy();
  virtual ~ServerIsBusy();

  ServerIsBusy(const ServerIsBusy& from);

  inline ServerIsBusy& operator=(const ServerIsBusy& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerIsBusy& default_instance();

  static const ServerIsBusy* internal_default_instance();

  void Swap(ServerIsBusy* other);

  // implements Message ----------------------------------------------

  inline ServerIsBusy* New() const { return New(NULL); }

  ServerIsBusy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerIsBusy& from);
  void MergeFrom(const ServerIsBusy& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerIsBusy* other);
  void UnsafeMergeFrom(const ServerIsBusy& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 1;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional uint64 backoff_ms = 2;
  void clear_backoff_ms();
  static const int kBackoffMsFieldNumber = 2;
  ::google::protobuf::uint64 backoff_ms() const;
  void set_backoff_ms(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.ServerIsBusy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::uint64 backoff_ms_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ServerIsBusy> ServerIsBusy_default_instance_;

// -------------------------------------------------------------------

class StaleCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.StaleCommand) */ {
 public:
  StaleCommand();
  virtual ~StaleCommand();

  StaleCommand(const StaleCommand& from);

  inline StaleCommand& operator=(const StaleCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaleCommand& default_instance();

  static const StaleCommand* internal_default_instance();

  void Swap(StaleCommand* other);

  // implements Message ----------------------------------------------

  inline StaleCommand* New() const { return New(NULL); }

  StaleCommand* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StaleCommand& from);
  void MergeFrom(const StaleCommand& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StaleCommand* other);
  void UnsafeMergeFrom(const StaleCommand& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:errorpb.StaleCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<StaleCommand> StaleCommand_default_instance_;

// -------------------------------------------------------------------

class RaftEntryTooLarge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.RaftEntryTooLarge) */ {
 public:
  RaftEntryTooLarge();
  virtual ~RaftEntryTooLarge();

  RaftEntryTooLarge(const RaftEntryTooLarge& from);

  inline RaftEntryTooLarge& operator=(const RaftEntryTooLarge& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftEntryTooLarge& default_instance();

  static const RaftEntryTooLarge* internal_default_instance();

  void Swap(RaftEntryTooLarge* other);

  // implements Message ----------------------------------------------

  inline RaftEntryTooLarge* New() const { return New(NULL); }

  RaftEntryTooLarge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftEntryTooLarge& from);
  void MergeFrom(const RaftEntryTooLarge& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RaftEntryTooLarge* other);
  void UnsafeMergeFrom(const RaftEntryTooLarge& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 region_id = 1;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // optional uint64 entry_size = 2;
  void clear_entry_size();
  static const int kEntrySizeFieldNumber = 2;
  ::google::protobuf::uint64 entry_size() const;
  void set_entry_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:errorpb.RaftEntryTooLarge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 region_id_;
  ::google::protobuf::uint64 entry_size_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RaftEntryTooLarge> RaftEntryTooLarge_default_instance_;

// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:errorpb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static const Error* internal_default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  inline Error* New() const { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Error* other);
  void UnsafeMergeFrom(const Error& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .errorpb.NotLeader not_leader = 2;
  bool has_not_leader() const;
  void clear_not_leader();
  static const int kNotLeaderFieldNumber = 2;
  const ::errorpb::NotLeader& not_leader() const;
  ::errorpb::NotLeader* mutable_not_leader();
  ::errorpb::NotLeader* release_not_leader();
  void set_allocated_not_leader(::errorpb::NotLeader* not_leader);

  // optional .errorpb.RegionNotFound region_not_found = 3;
  bool has_region_not_found() const;
  void clear_region_not_found();
  static const int kRegionNotFoundFieldNumber = 3;
  const ::errorpb::RegionNotFound& region_not_found() const;
  ::errorpb::RegionNotFound* mutable_region_not_found();
  ::errorpb::RegionNotFound* release_region_not_found();
  void set_allocated_region_not_found(::errorpb::RegionNotFound* region_not_found);

  // optional .errorpb.KeyNotInRegion key_not_in_region = 4;
  bool has_key_not_in_region() const;
  void clear_key_not_in_region();
  static const int kKeyNotInRegionFieldNumber = 4;
  const ::errorpb::KeyNotInRegion& key_not_in_region() const;
  ::errorpb::KeyNotInRegion* mutable_key_not_in_region();
  ::errorpb::KeyNotInRegion* release_key_not_in_region();
  void set_allocated_key_not_in_region(::errorpb::KeyNotInRegion* key_not_in_region);

  // optional .errorpb.StaleEpoch stale_epoch = 5;
  bool has_stale_epoch() const;
  void clear_stale_epoch();
  static const int kStaleEpochFieldNumber = 5;
  const ::errorpb::StaleEpoch& stale_epoch() const;
  ::errorpb::StaleEpoch* mutable_stale_epoch();
  ::errorpb::StaleEpoch* release_stale_epoch();
  void set_allocated_stale_epoch(::errorpb::StaleEpoch* stale_epoch);

  // optional .errorpb.ServerIsBusy server_is_busy = 6;
  bool has_server_is_busy() const;
  void clear_server_is_busy();
  static const int kServerIsBusyFieldNumber = 6;
  const ::errorpb::ServerIsBusy& server_is_busy() const;
  ::errorpb::ServerIsBusy* mutable_server_is_busy();
  ::errorpb::ServerIsBusy* release_server_is_busy();
  void set_allocated_server_is_busy(::errorpb::ServerIsBusy* server_is_busy);

  // optional .errorpb.StaleCommand stale_command = 7;
  bool has_stale_command() const;
  void clear_stale_command();
  static const int kStaleCommandFieldNumber = 7;
  const ::errorpb::StaleCommand& stale_command() const;
  ::errorpb::StaleCommand* mutable_stale_command();
  ::errorpb::StaleCommand* release_stale_command();
  void set_allocated_stale_command(::errorpb::StaleCommand* stale_command);

  // optional .errorpb.StoreNotMatch store_not_match = 8;
  bool has_store_not_match() const;
  void clear_store_not_match();
  static const int kStoreNotMatchFieldNumber = 8;
  const ::errorpb::StoreNotMatch& store_not_match() const;
  ::errorpb::StoreNotMatch* mutable_store_not_match();
  ::errorpb::StoreNotMatch* release_store_not_match();
  void set_allocated_store_not_match(::errorpb::StoreNotMatch* store_not_match);

  // optional .errorpb.RaftEntryTooLarge raft_entry_too_large = 9;
  bool has_raft_entry_too_large() const;
  void clear_raft_entry_too_large();
  static const int kRaftEntryTooLargeFieldNumber = 9;
  const ::errorpb::RaftEntryTooLarge& raft_entry_too_large() const;
  ::errorpb::RaftEntryTooLarge* mutable_raft_entry_too_large();
  ::errorpb::RaftEntryTooLarge* release_raft_entry_too_large();
  void set_allocated_raft_entry_too_large(::errorpb::RaftEntryTooLarge* raft_entry_too_large);

  // @@protoc_insertion_point(class_scope:errorpb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::errorpb::NotLeader* not_leader_;
  ::errorpb::RegionNotFound* region_not_found_;
  ::errorpb::KeyNotInRegion* key_not_in_region_;
  ::errorpb::StaleEpoch* stale_epoch_;
  ::errorpb::ServerIsBusy* server_is_busy_;
  ::errorpb::StaleCommand* stale_command_;
  ::errorpb::StoreNotMatch* store_not_match_;
  ::errorpb::RaftEntryTooLarge* raft_entry_too_large_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_errorpb_2eproto_impl();
  friend void  protobuf_AddDesc_errorpb_2eproto_impl();
  friend void protobuf_AssignDesc_errorpb_2eproto();
  friend void protobuf_ShutdownFile_errorpb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Error> Error_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// NotLeader

// optional uint64 region_id = 1;
inline void NotLeader::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 NotLeader::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.region_id)
  return region_id_;
}
inline void NotLeader::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.NotLeader.region_id)
}

// optional .metapb.Peer leader = 2;
inline bool NotLeader::has_leader() const {
  return this != internal_default_instance() && leader_ != NULL;
}
inline void NotLeader::clear_leader() {
  if (GetArenaNoVirtual() == NULL && leader_ != NULL) delete leader_;
  leader_ = NULL;
}
inline const ::metapb::Peer& NotLeader::leader() const {
  // @@protoc_insertion_point(field_get:errorpb.NotLeader.leader)
  return leader_ != NULL ? *leader_
                         : *::metapb::Peer::internal_default_instance();
}
inline ::metapb::Peer* NotLeader::mutable_leader() {
  
  if (leader_ == NULL) {
    leader_ = new ::metapb::Peer;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.NotLeader.leader)
  return leader_;
}
inline ::metapb::Peer* NotLeader::release_leader() {
  // @@protoc_insertion_point(field_release:errorpb.NotLeader.leader)
  
  ::metapb::Peer* temp = leader_;
  leader_ = NULL;
  return temp;
}
inline void NotLeader::set_allocated_leader(::metapb::Peer* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.NotLeader.leader)
}

inline const NotLeader* NotLeader::internal_default_instance() {
  return &NotLeader_default_instance_.get();
}
// -------------------------------------------------------------------

// StoreNotMatch

inline const StoreNotMatch* StoreNotMatch::internal_default_instance() {
  return &StoreNotMatch_default_instance_.get();
}
// -------------------------------------------------------------------

// RegionNotFound

// optional uint64 region_id = 1;
inline void RegionNotFound::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegionNotFound::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.RegionNotFound.region_id)
  return region_id_;
}
inline void RegionNotFound::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.RegionNotFound.region_id)
}

inline const RegionNotFound* RegionNotFound::internal_default_instance() {
  return &RegionNotFound_default_instance_.get();
}
// -------------------------------------------------------------------

// KeyNotInRegion

// optional bytes key = 1;
inline void KeyNotInRegion::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRegion::key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.key)
}
inline void KeyNotInRegion::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.key)
}
inline void KeyNotInRegion::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.key)
}
inline ::std::string* KeyNotInRegion::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRegion::release_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.key)
}

// optional uint64 region_id = 2;
inline void KeyNotInRegion::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 KeyNotInRegion::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.region_id)
  return region_id_;
}
inline void KeyNotInRegion::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.region_id)
}

// optional bytes start_key = 3;
inline void KeyNotInRegion::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRegion::start_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.start_key)
  return start_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.start_key)
}
inline void KeyNotInRegion::set_start_key(const char* value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.start_key)
}
inline void KeyNotInRegion::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.start_key)
}
inline ::std::string* KeyNotInRegion::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRegion::release_start_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.start_key)
}

// optional bytes end_key = 4;
inline void KeyNotInRegion::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyNotInRegion::end_key() const {
  // @@protoc_insertion_point(field_get:errorpb.KeyNotInRegion.end_key)
  return end_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.KeyNotInRegion.end_key)
}
inline void KeyNotInRegion::set_end_key(const char* value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.KeyNotInRegion.end_key)
}
inline void KeyNotInRegion::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.KeyNotInRegion.end_key)
}
inline ::std::string* KeyNotInRegion::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.KeyNotInRegion.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyNotInRegion::release_end_key() {
  // @@protoc_insertion_point(field_release:errorpb.KeyNotInRegion.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyNotInRegion::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:errorpb.KeyNotInRegion.end_key)
}

inline const KeyNotInRegion* KeyNotInRegion::internal_default_instance() {
  return &KeyNotInRegion_default_instance_.get();
}
// -------------------------------------------------------------------

// StaleEpoch

// repeated .metapb.Region new_regions = 1;
inline int StaleEpoch::new_regions_size() const {
  return new_regions_.size();
}
inline void StaleEpoch::clear_new_regions() {
  new_regions_.Clear();
}
inline const ::metapb::Region& StaleEpoch::new_regions(int index) const {
  // @@protoc_insertion_point(field_get:errorpb.StaleEpoch.new_regions)
  return new_regions_.Get(index);
}
inline ::metapb::Region* StaleEpoch::mutable_new_regions(int index) {
  // @@protoc_insertion_point(field_mutable:errorpb.StaleEpoch.new_regions)
  return new_regions_.Mutable(index);
}
inline ::metapb::Region* StaleEpoch::add_new_regions() {
  // @@protoc_insertion_point(field_add:errorpb.StaleEpoch.new_regions)
  return new_regions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metapb::Region >*
StaleEpoch::mutable_new_regions() {
  // @@protoc_insertion_point(field_mutable_list:errorpb.StaleEpoch.new_regions)
  return &new_regions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metapb::Region >&
StaleEpoch::new_regions() const {
  // @@protoc_insertion_point(field_list:errorpb.StaleEpoch.new_regions)
  return new_regions_;
}

inline const StaleEpoch* StaleEpoch::internal_default_instance() {
  return &StaleEpoch_default_instance_.get();
}
// -------------------------------------------------------------------

// ServerIsBusy

// optional string reason = 1;
inline void ServerIsBusy::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerIsBusy::reason() const {
  // @@protoc_insertion_point(field_get:errorpb.ServerIsBusy.reason)
  return reason_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerIsBusy::set_reason(const ::std::string& value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.ServerIsBusy.reason)
}
inline void ServerIsBusy::set_reason(const char* value) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.ServerIsBusy.reason)
}
inline void ServerIsBusy::set_reason(const char* value, size_t size) {
  
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.ServerIsBusy.reason)
}
inline ::std::string* ServerIsBusy::mutable_reason() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.ServerIsBusy.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerIsBusy::release_reason() {
  // @@protoc_insertion_point(field_release:errorpb.ServerIsBusy.reason)
  
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerIsBusy::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    
  } else {
    
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:errorpb.ServerIsBusy.reason)
}

// optional uint64 backoff_ms = 2;
inline void ServerIsBusy::clear_backoff_ms() {
  backoff_ms_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ServerIsBusy::backoff_ms() const {
  // @@protoc_insertion_point(field_get:errorpb.ServerIsBusy.backoff_ms)
  return backoff_ms_;
}
inline void ServerIsBusy::set_backoff_ms(::google::protobuf::uint64 value) {
  
  backoff_ms_ = value;
  // @@protoc_insertion_point(field_set:errorpb.ServerIsBusy.backoff_ms)
}

inline const ServerIsBusy* ServerIsBusy::internal_default_instance() {
  return &ServerIsBusy_default_instance_.get();
}
// -------------------------------------------------------------------

// StaleCommand

inline const StaleCommand* StaleCommand::internal_default_instance() {
  return &StaleCommand_default_instance_.get();
}
// -------------------------------------------------------------------

// RaftEntryTooLarge

// optional uint64 region_id = 1;
inline void RaftEntryTooLarge::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RaftEntryTooLarge::region_id() const {
  // @@protoc_insertion_point(field_get:errorpb.RaftEntryTooLarge.region_id)
  return region_id_;
}
inline void RaftEntryTooLarge::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:errorpb.RaftEntryTooLarge.region_id)
}

// optional uint64 entry_size = 2;
inline void RaftEntryTooLarge::clear_entry_size() {
  entry_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RaftEntryTooLarge::entry_size() const {
  // @@protoc_insertion_point(field_get:errorpb.RaftEntryTooLarge.entry_size)
  return entry_size_;
}
inline void RaftEntryTooLarge::set_entry_size(::google::protobuf::uint64 value) {
  
  entry_size_ = value;
  // @@protoc_insertion_point(field_set:errorpb.RaftEntryTooLarge.entry_size)
}

inline const RaftEntryTooLarge* RaftEntryTooLarge::internal_default_instance() {
  return &RaftEntryTooLarge_default_instance_.get();
}
// -------------------------------------------------------------------

// Error

// optional string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:errorpb.Error.message)
}
inline void Error::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:errorpb.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:errorpb.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:errorpb.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:errorpb.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.message)
}

// optional .errorpb.NotLeader not_leader = 2;
inline bool Error::has_not_leader() const {
  return this != internal_default_instance() && not_leader_ != NULL;
}
inline void Error::clear_not_leader() {
  if (GetArenaNoVirtual() == NULL && not_leader_ != NULL) delete not_leader_;
  not_leader_ = NULL;
}
inline const ::errorpb::NotLeader& Error::not_leader() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.not_leader)
  return not_leader_ != NULL ? *not_leader_
                         : *::errorpb::NotLeader::internal_default_instance();
}
inline ::errorpb::NotLeader* Error::mutable_not_leader() {
  
  if (not_leader_ == NULL) {
    not_leader_ = new ::errorpb::NotLeader;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.not_leader)
  return not_leader_;
}
inline ::errorpb::NotLeader* Error::release_not_leader() {
  // @@protoc_insertion_point(field_release:errorpb.Error.not_leader)
  
  ::errorpb::NotLeader* temp = not_leader_;
  not_leader_ = NULL;
  return temp;
}
inline void Error::set_allocated_not_leader(::errorpb::NotLeader* not_leader) {
  delete not_leader_;
  not_leader_ = not_leader;
  if (not_leader) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.not_leader)
}

// optional .errorpb.RegionNotFound region_not_found = 3;
inline bool Error::has_region_not_found() const {
  return this != internal_default_instance() && region_not_found_ != NULL;
}
inline void Error::clear_region_not_found() {
  if (GetArenaNoVirtual() == NULL && region_not_found_ != NULL) delete region_not_found_;
  region_not_found_ = NULL;
}
inline const ::errorpb::RegionNotFound& Error::region_not_found() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.region_not_found)
  return region_not_found_ != NULL ? *region_not_found_
                         : *::errorpb::RegionNotFound::internal_default_instance();
}
inline ::errorpb::RegionNotFound* Error::mutable_region_not_found() {
  
  if (region_not_found_ == NULL) {
    region_not_found_ = new ::errorpb::RegionNotFound;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.region_not_found)
  return region_not_found_;
}
inline ::errorpb::RegionNotFound* Error::release_region_not_found() {
  // @@protoc_insertion_point(field_release:errorpb.Error.region_not_found)
  
  ::errorpb::RegionNotFound* temp = region_not_found_;
  region_not_found_ = NULL;
  return temp;
}
inline void Error::set_allocated_region_not_found(::errorpb::RegionNotFound* region_not_found) {
  delete region_not_found_;
  region_not_found_ = region_not_found;
  if (region_not_found) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.region_not_found)
}

// optional .errorpb.KeyNotInRegion key_not_in_region = 4;
inline bool Error::has_key_not_in_region() const {
  return this != internal_default_instance() && key_not_in_region_ != NULL;
}
inline void Error::clear_key_not_in_region() {
  if (GetArenaNoVirtual() == NULL && key_not_in_region_ != NULL) delete key_not_in_region_;
  key_not_in_region_ = NULL;
}
inline const ::errorpb::KeyNotInRegion& Error::key_not_in_region() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.key_not_in_region)
  return key_not_in_region_ != NULL ? *key_not_in_region_
                         : *::errorpb::KeyNotInRegion::internal_default_instance();
}
inline ::errorpb::KeyNotInRegion* Error::mutable_key_not_in_region() {
  
  if (key_not_in_region_ == NULL) {
    key_not_in_region_ = new ::errorpb::KeyNotInRegion;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.key_not_in_region)
  return key_not_in_region_;
}
inline ::errorpb::KeyNotInRegion* Error::release_key_not_in_region() {
  // @@protoc_insertion_point(field_release:errorpb.Error.key_not_in_region)
  
  ::errorpb::KeyNotInRegion* temp = key_not_in_region_;
  key_not_in_region_ = NULL;
  return temp;
}
inline void Error::set_allocated_key_not_in_region(::errorpb::KeyNotInRegion* key_not_in_region) {
  delete key_not_in_region_;
  key_not_in_region_ = key_not_in_region;
  if (key_not_in_region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.key_not_in_region)
}

// optional .errorpb.StaleEpoch stale_epoch = 5;
inline bool Error::has_stale_epoch() const {
  return this != internal_default_instance() && stale_epoch_ != NULL;
}
inline void Error::clear_stale_epoch() {
  if (GetArenaNoVirtual() == NULL && stale_epoch_ != NULL) delete stale_epoch_;
  stale_epoch_ = NULL;
}
inline const ::errorpb::StaleEpoch& Error::stale_epoch() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_epoch)
  return stale_epoch_ != NULL ? *stale_epoch_
                         : *::errorpb::StaleEpoch::internal_default_instance();
}
inline ::errorpb::StaleEpoch* Error::mutable_stale_epoch() {
  
  if (stale_epoch_ == NULL) {
    stale_epoch_ = new ::errorpb::StaleEpoch;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_epoch)
  return stale_epoch_;
}
inline ::errorpb::StaleEpoch* Error::release_stale_epoch() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_epoch)
  
  ::errorpb::StaleEpoch* temp = stale_epoch_;
  stale_epoch_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_epoch(::errorpb::StaleEpoch* stale_epoch) {
  delete stale_epoch_;
  stale_epoch_ = stale_epoch;
  if (stale_epoch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_epoch)
}

// optional .errorpb.ServerIsBusy server_is_busy = 6;
inline bool Error::has_server_is_busy() const {
  return this != internal_default_instance() && server_is_busy_ != NULL;
}
inline void Error::clear_server_is_busy() {
  if (GetArenaNoVirtual() == NULL && server_is_busy_ != NULL) delete server_is_busy_;
  server_is_busy_ = NULL;
}
inline const ::errorpb::ServerIsBusy& Error::server_is_busy() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.server_is_busy)
  return server_is_busy_ != NULL ? *server_is_busy_
                         : *::errorpb::ServerIsBusy::internal_default_instance();
}
inline ::errorpb::ServerIsBusy* Error::mutable_server_is_busy() {
  
  if (server_is_busy_ == NULL) {
    server_is_busy_ = new ::errorpb::ServerIsBusy;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.server_is_busy)
  return server_is_busy_;
}
inline ::errorpb::ServerIsBusy* Error::release_server_is_busy() {
  // @@protoc_insertion_point(field_release:errorpb.Error.server_is_busy)
  
  ::errorpb::ServerIsBusy* temp = server_is_busy_;
  server_is_busy_ = NULL;
  return temp;
}
inline void Error::set_allocated_server_is_busy(::errorpb::ServerIsBusy* server_is_busy) {
  delete server_is_busy_;
  server_is_busy_ = server_is_busy;
  if (server_is_busy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.server_is_busy)
}

// optional .errorpb.StaleCommand stale_command = 7;
inline bool Error::has_stale_command() const {
  return this != internal_default_instance() && stale_command_ != NULL;
}
inline void Error::clear_stale_command() {
  if (GetArenaNoVirtual() == NULL && stale_command_ != NULL) delete stale_command_;
  stale_command_ = NULL;
}
inline const ::errorpb::StaleCommand& Error::stale_command() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.stale_command)
  return stale_command_ != NULL ? *stale_command_
                         : *::errorpb::StaleCommand::internal_default_instance();
}
inline ::errorpb::StaleCommand* Error::mutable_stale_command() {
  
  if (stale_command_ == NULL) {
    stale_command_ = new ::errorpb::StaleCommand;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.stale_command)
  return stale_command_;
}
inline ::errorpb::StaleCommand* Error::release_stale_command() {
  // @@protoc_insertion_point(field_release:errorpb.Error.stale_command)
  
  ::errorpb::StaleCommand* temp = stale_command_;
  stale_command_ = NULL;
  return temp;
}
inline void Error::set_allocated_stale_command(::errorpb::StaleCommand* stale_command) {
  delete stale_command_;
  stale_command_ = stale_command;
  if (stale_command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.stale_command)
}

// optional .errorpb.StoreNotMatch store_not_match = 8;
inline bool Error::has_store_not_match() const {
  return this != internal_default_instance() && store_not_match_ != NULL;
}
inline void Error::clear_store_not_match() {
  if (GetArenaNoVirtual() == NULL && store_not_match_ != NULL) delete store_not_match_;
  store_not_match_ = NULL;
}
inline const ::errorpb::StoreNotMatch& Error::store_not_match() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.store_not_match)
  return store_not_match_ != NULL ? *store_not_match_
                         : *::errorpb::StoreNotMatch::internal_default_instance();
}
inline ::errorpb::StoreNotMatch* Error::mutable_store_not_match() {
  
  if (store_not_match_ == NULL) {
    store_not_match_ = new ::errorpb::StoreNotMatch;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.store_not_match)
  return store_not_match_;
}
inline ::errorpb::StoreNotMatch* Error::release_store_not_match() {
  // @@protoc_insertion_point(field_release:errorpb.Error.store_not_match)
  
  ::errorpb::StoreNotMatch* temp = store_not_match_;
  store_not_match_ = NULL;
  return temp;
}
inline void Error::set_allocated_store_not_match(::errorpb::StoreNotMatch* store_not_match) {
  delete store_not_match_;
  store_not_match_ = store_not_match;
  if (store_not_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.store_not_match)
}

// optional .errorpb.RaftEntryTooLarge raft_entry_too_large = 9;
inline bool Error::has_raft_entry_too_large() const {
  return this != internal_default_instance() && raft_entry_too_large_ != NULL;
}
inline void Error::clear_raft_entry_too_large() {
  if (GetArenaNoVirtual() == NULL && raft_entry_too_large_ != NULL) delete raft_entry_too_large_;
  raft_entry_too_large_ = NULL;
}
inline const ::errorpb::RaftEntryTooLarge& Error::raft_entry_too_large() const {
  // @@protoc_insertion_point(field_get:errorpb.Error.raft_entry_too_large)
  return raft_entry_too_large_ != NULL ? *raft_entry_too_large_
                         : *::errorpb::RaftEntryTooLarge::internal_default_instance();
}
inline ::errorpb::RaftEntryTooLarge* Error::mutable_raft_entry_too_large() {
  
  if (raft_entry_too_large_ == NULL) {
    raft_entry_too_large_ = new ::errorpb::RaftEntryTooLarge;
  }
  // @@protoc_insertion_point(field_mutable:errorpb.Error.raft_entry_too_large)
  return raft_entry_too_large_;
}
inline ::errorpb::RaftEntryTooLarge* Error::release_raft_entry_too_large() {
  // @@protoc_insertion_point(field_release:errorpb.Error.raft_entry_too_large)
  
  ::errorpb::RaftEntryTooLarge* temp = raft_entry_too_large_;
  raft_entry_too_large_ = NULL;
  return temp;
}
inline void Error::set_allocated_raft_entry_too_large(::errorpb::RaftEntryTooLarge* raft_entry_too_large) {
  delete raft_entry_too_large_;
  raft_entry_too_large_ = raft_entry_too_large;
  if (raft_entry_too_large) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:errorpb.Error.raft_entry_too_large)
}

inline const Error* Error::internal_default_instance() {
  return &Error_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace errorpb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_errorpb_2eproto__INCLUDED
